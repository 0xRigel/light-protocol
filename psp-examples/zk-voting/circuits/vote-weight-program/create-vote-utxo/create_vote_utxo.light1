pragma circom 2.1.4;
include "../../node_modules/circomlib/circuits/poseidon.circom";
include "../../node_modules/@lightprotocol/zk.js/circuit-lib/merkleProof.circom";
include "../../node_modules/@lightprotocol/zk.js/circuit-lib/keypair.circom";
include "../../node_modules/circomlib/circuits/gates.circom";
include "../../node_modules/circomlib/circuits/comparators.circom";

// will create a new instance of the circuit
#[instance]
{
    fileName: create_vote_utxo,
    config(),
    // TODO: distinguish between nrOutAppUtxos and nrInAppUtxos
    // TODO: enable in and out app utxos to be optional depending on an instruction flag in this case create, close
    // nrAppUtoxs: 0,
    publicInputs: [publicMint,publicReleaseSlot, maxLockTime]
}
/*
- the instance should include which verifier to instantiate the circuit with
- the instance should not hold the number of app utxos the instruction should
*/


#[lightTransaction(verifierTwo)]
template create_vote_utxo() {
    // Defines the data which is saved in the utxo
    // utxoData variables need to be lowerCamelCase
    // #[utxoData]
    // {
    //     voteWeight,
    //     releaseSlot,
    //     voteLock
    // }
    signal input create;
    signal input voteWeight;
    signal input releaseSlot;
    signal input voteLock;
    signal input publicMint;
    signal input maxLockTime;


    signal isAppOutUtxo[nOuts];
    // signal input close;
    // instruction either creates or closes the 
    // component checkCreateOrClose = OR();

    signal input publicReleaseSlot;
    
    // not locked at creation or closing
    voteLock === 0;
    // release slot has to be greater than the current slot onchain
    // only checked at creation
    component checkReleaseSlot = GreaterThan(64);
    checkReleaseSlot.in[0] <== releaseSlot;
    checkReleaseSlot.in[1] <== publicReleaseSlot;
    checkReleaseSlot.out === 1 * create;

    component checkMaxLockTime = LessThan(64);
    checkReleaseSlot.in[0] <== releaseSlot - publicReleaseSlot;
    checkReleaseSlot.in[1] <== maxLockTime;
    checkReleaseSlot.out === 1 * create;

    // doesn't work as long as I cannot have optional input app utxos
    // release slot has to be reached to close the utxo
    // component checkReleaseSlot = GreaterThan(64);
    // checkReleaseSlot.in[0] <== publicReleaseSlot;
    // checkReleaseSlot.in[1] <== releaseSlot;
    // checkReleaseSlot.out === 1 * close;

    component checkVoteWeight[nOuts];
    component checkAsset[nOuts]
    component enableCheckVoteWeight[nOuts];

    for (let i = 0; i < nOuts; i++) {
        checkVoteWeight[i] = CheckVoteWeight();
        checkVoteWeight.x <== releaseSlot;
        checkVoteWeight.value <== inAmount[i][1];
        enableCheckVoteWeight[i] = ForceEqualIfEnabled();
        enableCheckVoteWeight.in[0] <== voteWeight;
        enableCheckVoteWeight.in[1] <== checkVoteWeight.out;
        enableCheckVoteWeight.enable <== isAppOutUtxo[i];
        checkAsset[i] = ForceEqualIfEnabled();
        checkAsset.in[0] <== inAsset[i][1];
        checkAsset.in[1] <== publicMint;
        checkAsset.enable <== isAppOutUtxo[i];
    }

    component outAppDataHasher = Poseidon(3);
    outAppDataHasher.in[0] <== voteWeight;
    outAppDataHasher.in[1] <== releaseSlot;
    outAppDataHasher.in[2] <== voteLock;

    component checkOutUtxo[nOuts];
    for (let i = 0; i < nOuts; i++) {
        checkOutUtxo = EnforceEqualIfEnabled();
        checkOutUtxo.in[0] <== outAppDataHash[i];
        checkOutUtxo.in[1] <== outAppDataHasher.out;
        checkOutUtxo.enable <== isAppOutUtxo[i];
    }
    // check that all isOutUtxo are either one or zero
    // and that there is exactly one one in the array
    component checkIndices = CheckIndices(nOuts);
    checkIndices.indices <== isOutUtxo;
    checkIndices.threshold <== 1;
    checkIndices.enabled <== create;
}

// checks one dim indices array that every index is 0 or 1
// and that threshold of indices are 1
template CheckIndices(n) {
    signal input indices[n];    
    signal input threshold;
    signal input enabled;
    var varSumIndices = 0;
    for (var j = 0; j < n; j++) {
        varSumIndices += indices[j];
        // all indices are 0 or 1
        indices[j] * (1 - indices[j]) === 0;
    }
    component checkIfEnabled = ForceEqualIfEnabled();
    checkIfEnabled.in[0] <== threshold;
    checkIfEnabled.in[1] <== varSumIndices;
    checkIfEnabled.enabled <== enabled;
}
template CheckVoteWeight() {
    signal input x;
    signal input value;
    signal input c;
    signal output y;

    y <== x * value + c;
}

/*
* Environment Constants:
*   levels = 18
*   nIns = 4 (number of in utxos)
*   nOuts = 4 (number of out utxos)
*   feeAsset = TruncatedSha256(0)
*   indexFeeAsset = 0
*   indexPublicAsset = 1
*   nAssets = 3
*   nInAssets = 2
*   nOutAssets = 2
* Environment variables:
*   txIntegrityHash;
*   transactionVersion;
*   publicAppVerifier;
*   transactionHash;
*   instructionHasher.out;
*   isAppInUtxo[nAppUtxos][nIns];
*   
*  InUtxos:
*   inAmount[nIns][nInAssets];
*   inPublicKey[nIns];
*   inBlinding[nIns];
*   inAppDataHash[nIns];
*   inPoolType[nIns];
*   inVerifierPubkey[nIns];
*   inIndices[nIns][nInAssets][nAssets];
* OutUtxos:
*   outputCommitment[nOuts];
*   outAmount[nOuts][nOutAssets];
*   outPubkey[nOuts];
*   outBlinding[nOuts];
*   outAppDataHash[nOuts];
*   outIndices[nOuts][nOutAssets][nAssets];
*   outPoolType[nOuts];
*   outVerifierPubkey[nOuts];
*/