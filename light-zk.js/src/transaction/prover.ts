const snarkjs = require("snarkjs");
const { unstringifyBigInts, stringifyBigInts, leInt2Buff } =
  require("ffjavascript").utils;

import { Idl } from "@coral-xyz/anchor";
import { VerifierError, VerifierErrorCode } from "../errors";

/** This type represents a proof data object in a zk-SNARK system, as generated by SNARKJS. */
export type proofData = {
  /** Represents the values of the polynomial evaluation at a secret point for the polynomial `A(x)`. */
  pi_a: string[];

  /** Represents the values of the polynomial evaluation at a secret point for the polynomial `B(x)`. */
  pi_b: string[][];

  /** Represents the values of the polynomial evaluation at a secret point for the polynomial `C(x)`. */
  pi_c: string[];

  /** The protocol used in the proof system: groth16 or plonk. */
  protocol: string;

  /** The elliptic curve used in the proof system: bn128, bls12381, goldilocks [default: bn128]. */
  curve: string;
};

/** This type represents a verification key data object in a zk-SNARK system, as generated by SNARKJS. */
export type vKeyData = {
  /** The protocol used in the proof system: groth16 or plonk. */
  protocol: string;

  /** The elliptic curve used in the proof system: bn128, bls12381, goldilocks [default: bn128]. */
  curve: string;

  /** The number of public inputs for the zk-SNARK. */
  nPublic: number;

  /** An element of the verification key, corresponding to the encoded evaluation of polynomial `A(x)` at the secret point (The alpha vector in G1). */
  vk_alpha_1: string[];

  /** An element of the verification key, corresponding to the encoded evaluation of polynomial `B(x)` at the secret point (The beta vector in G2). */
  vk_beta_2: string[][];

  /** An element of the verification key, often used to encode the combination of `A(x)`, `B(x)`, and `C(x)` (The gamma vector in G2). */
  vk_gamma_2: string[][];

  /** An element of the verification key, often used to encode a normalizing factor in the proof (The delta vector in G2). */
  vk_delta_2: string[][];

  /** An element of the verification key, often used to encode a pre-computed element for efficiency (The alpha * beta value in GT). */
  vk_alphabeta_12: ArrayConstructor[][][];

  /** The encoded evaluation of the input consistency polynomial at the secret point (The query vector for the linear combination of the inputs). */
  IC: string[][];
};

/**
 * Prover class for zero-knowledge proof systems using SNARKJS and CIRCOM circuits.
 */
export class Prover {
  public circuitName!: string;
  public idl: Idl;
  public firstPath: string;
  public wasmPath!: string;
  public zkeyPath!: string;
  public proofInputs: any;
  public publicInputs: string[] = [];
  public vKey!: vKeyData;
  public proof!: proofData;

  /**
   * Constructs a new Prover instance.
   * @param idl - The Interface Description Language (IDL) for the proof system, as generated by ANCHOR framework.
   * Used to retrieve a parsed account struct to read an object of a circuit proof inputs.
   * @param firstPath - The initial path used for building paths to circuit-related files i.e. wasm and zkey files.
   */
  constructor(idl: Idl, firstPath: string) {
    this.idl = idl;
    this.firstPath = firstPath;
  }

  /**
   * Adds proof inputs after reading and parsing the circuit's proof inputs struct from the idl.
   * @param proofInputs - An object containing the proof inputs to be added. The keys of this object
   *                      should correspond to the field names in the zk-SNARK circuit's proof inputs
   *                      structure in the IDL, and the values should be the corresponding proof inputs.
   * @throws {Error} Will throw an error if the circuit's proof inputs structure does not exist in
   *                 the IDL, or if any of the required proof inputs is missing.
   */
  async addProofInputs(proofInputs: any) {
    // Filter accounts that contain zK and either PublicInputs or ProofInputs

    const ZKAccountNames = this.idl.accounts
      ?.filter((account) =>
        /zK.*(?:PublicInputs|ProofInputs)|zk.*(?:PublicInputs|ProofInputs)/.test(
          account.name,
        ),
      )
      .map((account) => account.name);

    // Extract the circuit names and store them in a Set to get unique names
    const circuitNameRegex =
      /zK(.*?)ProofInputs|zK(.*?)PublicInputs|zk(.*?)ProofInputs|zk(.*?)PublicInputs/;
    const uniqueCircuitNames = new Set<string>();

    ZKAccountNames?.forEach((name) => {
      const match = name.match(circuitNameRegex);
      if (match) {
        uniqueCircuitNames.add(match[1] || match[2] || match[3] || match[4]);
      }
    });

    this.circuitName = Array.from(uniqueCircuitNames)[0];

    // After Retrieving circuitName ==> build wasm and zkey paths for the circuit
    this.wasmPath =
      this.firstPath + `/${this.circuitName}_js/${this.circuitName}.wasm`;
    this.zkeyPath = this.firstPath + `/${this.circuitName}.zkey`;

    const circuitIdlObject = this.idl.accounts!.find(
      (account) =>
        account.name.toUpperCase() ===
        `zK${this.circuitName}ProofInputs`.toUpperCase(),
    );

    if (!circuitIdlObject) {
      throw new Error(
        `${`zK${this.circuitName}ProofInputs`} does not exist in anchor idl`,
      );
    }

    const fieldNames = circuitIdlObject.type.fields.map(
      (field: { name: string }) => field.name,
    );
    const inputKeys: string[] = [];

    fieldNames.forEach((fieldName: string) => {
      inputKeys.push(fieldName);
    });

    let inputsObject: { [key: string]: any } = {};

    inputKeys.forEach((key) => {
      inputsObject[key] = proofInputs[key];
      if (!inputsObject[key])
        throw new Error(
          `Missing input --> ${key.toString()} in circuit ==> ${
            this.circuitName
          }`,
        );
    });
    this.proofInputs = inputsObject;
  }

  /** Generate a zk-SNARK proof & publicSignals using the Groth16 proving scheme. */
  async fullProve() {
    const { proof, publicSignals } = await snarkjs.groth16.fullProve(
      stringifyBigInts(this.proofInputs),
      this.wasmPath,
      this.zkeyPath,
    );

    this.publicInputs = publicSignals;
    this.proof = proof;
  }
  /** Get exported verification key from the zkey file that will be used later for proof verification*/
  async getVkey() {
    const vKey = await snarkjs.zKey.exportVerificationKey(this.zkeyPath);
    this.vKey = vKey;
  }

  /**
   * Verifies the proof generated by this class or a passed in proof.
   * @param proof - The optional proof to be verified. If not provided, the proof generated by this class is verified.
   * @returns A promise that resolves to a boolean indicating whether the proof is valid.
   */
  async verify(proof?: proofData): Promise<boolean> {
    // verifies the proof generated by this class or a passed in proof
    await this.getVkey();
    const res = await snarkjs.groth16.verify(
      this.vKey,
      this.publicInputs,
      this.proof,
    );
    return res;
  }

  /**
   * Parses a proof to a bytes array that will be used for zk proof verification for the groth16-solana crate.
   * @param proof - The proof to be parsed.
   * @returns An object containing the parsed proof.
   */
  parseProofToBytesArray(proof: proofData): {
    proofA: number[];
    proofB: number[][];
    proofC: number[];
  } {
    let proofJson = JSON.stringify(proof, null, 1);
    var mydata = JSON.parse(proofJson.toString());
    try {
      for (var i in mydata) {
        if (i == "pi_a" || i == "pi_c") {
          for (var j in mydata[i]) {
            mydata[i][j] = Array.from(
              leInt2Buff(unstringifyBigInts(mydata[i][j]), 32),
            ).reverse();
          }
        } else if (i == "pi_b") {
          for (var j in mydata[i]) {
            for (var z in mydata[i][j]) {
              mydata[i][j][z] = Array.from(
                leInt2Buff(unstringifyBigInts(mydata[i][j][z]), 32),
              );
            }
          }
        }
      }

      return {
        proofA: [mydata.pi_a[0], mydata.pi_a[1]].flat(),
        proofB: [
          mydata.pi_b[0].flat().reverse(),
          mydata.pi_b[1].flat().reverse(),
        ].flat(),
        proofC: [mydata.pi_c[0], mydata.pi_c[1]].flat(),
      };
    } catch (error) {
      console.error("error while parsing the proof!");
      throw error;
    }
  }

  /**
   * Parses public signals to a bytes array.
   * @param publicSignals - The public signals to be parsed.
   * @returns An array of n public inputs parsed into a number array and pushed according to the same order of the input.
   */
  parseToBytesArray(publicSignals: string[]): number[][] {
    const publicInputsJson = JSON.stringify(publicSignals, null, 1);
    var publicInputsBytesJson = JSON.parse(publicInputsJson.toString());
    try {
      var publicInputsBytes = new Array<Array<number>>();
      for (var i in publicInputsBytesJson) {
        let ref: Array<number> = Array.from([
          ...leInt2Buff(unstringifyBigInts(publicInputsBytesJson[i]), 32),
        ]).reverse();
        publicInputsBytes.push(ref);
      }

      return publicInputsBytes;
    } catch (error) {
      console.error("error while parsing public inputs!");
      throw error;
    }
  }

  /**
   * Performs a full proof generation and parsing process.
   * @returns An object containing the parsed proof and parsed public inputs.
   */
  async fullProveAndParse() {
    await this.fullProve();

    const parsedPublicInputsObj = this.parseToBytesArray(this.publicInputs);
    const parsedProofObj = this.parseProofToBytesArray(this.proof);

    return {
      parsedProof: parsedProofObj,
      parsedPublicInputs: parsedPublicInputsObj,
    };
  }

  /**
   * @param publicInputsBytes - A two-dimensional array of numbers representing the public inputs
   *                            for a zk-SNARK, where each inner array is a byte array of a public input value.
   * @returns An object where each key is the name of a public input, and each value is the parsed public
   *          input value. The shape and structure of the values depend on the specific zk-SNARK circuit.
   * @throws {VerifierError} Will throw an error if the public input array is undefined, or if the number
   *                         of public inputs does not match the expected number.
   */
  parsePublicInputsFromArray(publicInputsBytes: number[][]): any {
    type SizeObject = {
      [key: string]: number[];
    };

    function getNrPublicInputs(input: SizeObject): number {
      let arr = [];
      for (const key in input) {
        arr.push(...input[key]);
      }
      const updatedArray = arr.map((value) => (value === 0 ? 1 : value));

      return updatedArray.reduce(
        (accumulator, currentValue) => accumulator + currentValue,
        0,
      );
    }

    function getSize(type: any): number[] {
      const sizeArray = [];
      if (typeof type === "string") {
        sizeArray.push(0);
      } else if (Array.isArray(type)) {
        if (typeof type[0] === "string") {
          sizeArray.push(type[1]);
        } else {
          sizeArray.push(...getSize(type[0]), type[1]);
        }
      } else {
        return getSize(type.array);
      }

      return sizeArray;
    }

    function getObjectSizes(idlObject: any): SizeObject {
      let output: SizeObject = {};

      for (const field of idlObject[0].type.fields) {
        output[field.name] = getSize(field.type);
      }

      return output;
    }

    type NestedNumberArray = number | NestedNumberArray[];

    type OutputObject = {
      [key: string]: NestedNumberArray;
    };

    function spreadArrayToObject(input: number[][], sizes: SizeObject): any {
      let currentIndex = 0;

      const output: OutputObject = {};

      for (const key in sizes) {
        if (!sizes.hasOwnProperty(key)) {
          continue;
        }

        const shape = sizes[key];
        if (shape.length === 1 && shape[0] === 0) {
          output[key] = input[currentIndex];
          currentIndex += 1;
        } else {
          const totalElements = shape.reduce(
            (accumulator, size) => accumulator * size,
            1,
          );
          const slicedArray = input.slice(
            currentIndex,
            currentIndex + totalElements,
          );
          let reshapedArray: any = slicedArray;

          if (shape.length > 1) {
            let currentData = reshapedArray;
            for (let i = 0; i < shape.length - 1; i++) {
              currentData = currentData.reduce(
                (accumulator: any[], _: any, index: number) => {
                  if (index % shape[i] === 0) {
                    accumulator.push(
                      currentData.slice(index, index + shape[i]),
                    );
                  }
                  return accumulator;
                },
                [],
              );
            }
            reshapedArray = currentData;
          }

          output[key] = reshapedArray;
          currentIndex += totalElements;
        }
      }

      if (currentIndex !== input.length) {
        throw new Error(
          `Input array length mismatch: ${currentIndex} != ${input.length}`,
        );
      }

      return output;
    }

    if (!publicInputsBytes) {
      throw new VerifierError(
        VerifierErrorCode.PUBLIC_INPUTS_UNDEFINED,
        "parsePublicInputsFromArray",
        this.circuitName,
      );
    }

    const publicInputs_IdlObject = this.idl.accounts!.find(
      (account) =>
        account.name.toUpperCase() ===
        `ZK${this.circuitName}PublicInputs`.toUpperCase(),
    );

    const key_sizes = getObjectSizes([publicInputs_IdlObject]);
    const nrPublicInputs = getNrPublicInputs(key_sizes);

    if (publicInputsBytes.length != nrPublicInputs) {
      throw new VerifierError(
        VerifierErrorCode.INVALID_INPUTS_NUMBER,
        "parsePublicInputsFromArray",
        `${this.circuitName}: publicInputsBytes.length invalid ${publicInputsBytes.length} != ${nrPublicInputs}`,
      );
    }

    const result = spreadArrayToObject(publicInputsBytes, key_sizes);

    return result;
  }
}
